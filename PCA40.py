import pandas as pd
from sklearn import preprocessing
from sklearn.decomposition import PCA
import math # for the important features

# CREATE THE DATAFRAME 
df = pd.read_csv("MwFamSplits/MW2.csv", encoding = "ISO-8859-1")
df.drop(["filename"], 1 , inplace = True)
df.drop(["malware family"], 1 , inplace = True)

############### PCA FOR 40 COMPONANTS ######################################

# Scale the data frame: maxabs_scale is best for sparse data  
df_scaled = preprocessing.maxabs_scale(df, axis=0, copy=True)

# Createing model - Componanats:40 compnanats expalins approximatly 95% of the variance 
pca = PCA(n_components=40, svd_solver='auto') # svd_solver='auto': Automatic selection 
pca.fit(df_scaled)

T = pca.transform(df_scaled) # 'transform' method to apply dimensionality reduction to the data

components = pd.DataFrame(pca.components_, columns = df.columns, index=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]) # 

print("VE:", pca.explained_variance_ratio_.sum())


def get_important_features(transformed_features, components_, columns):
    """
    This function will return the most "important" 
    features so we can determine which have the most
    effect on multi-dimensional scaling
    """
    num_columns = len(columns)

    # Scale the principal components by the max value in
    # the transformed set belonging to that component
    vector_1 = components_[0] * max(transformed_features[:,0])
    vector_2 = components_[1] * max(transformed_features[:,1])
    vector_3 = components_[2] * max(transformed_features[:,2])
    vector_4 = components_[3] * max(transformed_features[:,3])
    vector_5 = components_[4] * max(transformed_features[:,4])
    vector_6 = components_[5] * max(transformed_features[:,5])
    vector_7 = components_[6] * max(transformed_features[:,6])
    vector_8 = components_[7] * max(transformed_features[:,7])
    vector_9 = components_[8] * max(transformed_features[:,8])
    vector_10 = components_[9] * max(transformed_features[:,9])
    vector_11 = components_[10] * max(transformed_features[:,10])
    vector_12 = components_[11] * max(transformed_features[:,11])
    vector_13 = components_[12] * max(transformed_features[:,12])
    vector_14 = components_[13] * max(transformed_features[:,13])
    vector_15 = components_[14] * max(transformed_features[:,14])
    vector_16 = components_[15] * max(transformed_features[:,15])
    vector_17 = components_[16] * max(transformed_features[:,16])
    vector_18 = components_[17] * max(transformed_features[:,17])
    vector_19 = components_[18] * max(transformed_features[:,18])
    vector_20 = components_[19] * max(transformed_features[:,19])
    vector_21 = components_[20] * max(transformed_features[:,20])
    vector_22 = components_[21] * max(transformed_features[:,21])
    vector_23 = components_[22] * max(transformed_features[:,22])
    vector_24 = components_[23] * max(transformed_features[:,23])
    vector_25 = components_[24] * max(transformed_features[:,24])
    vector_26 = components_[25] * max(transformed_features[:,25])
    vector_27 = components_[26] * max(transformed_features[:,26])
    vector_28 = components_[27] * max(transformed_features[:,27])
    vector_29 = components_[28] * max(transformed_features[:,28])
    vector_30 = components_[29] * max(transformed_features[:,29])
    vector_31 = components_[30] * max(transformed_features[:,30])
    vector_32 = components_[31] * max(transformed_features[:,31])
    vector_33 = components_[32] * max(transformed_features[:,32])
    vector_34 = components_[33] * max(transformed_features[:,33])
    vector_35 = components_[34] * max(transformed_features[:,34])
    vector_36 = components_[35] * max(transformed_features[:,35])
    vector_37 = components_[36] * max(transformed_features[:,36])
    vector_38 = components_[37] * max(transformed_features[:,37])
    vector_39 = components_[38] * max(transformed_features[:,38])
    vector_40 = components_[39] * max(transformed_features[:,39])

    # Sort each column by it's length. These are your *original*
    # columns, not the principal components.
    important_features = { columns[i] : math.sqrt(vector_1[i]**2 + vector_2[i]**2 + vector_3[i]**2 + vector_3[i]**2 
                          + vector_4[i]**2 + vector_5[i]**2 + vector_6[i]**2 + vector_7[i]**2
                          + vector_8[i]**2 + vector_9[i]**2 + vector_10[i]**2 
                          + vector_11[i]**2 + vector_12[i]**2 + vector_13[i]**2 + vector_14[i]**2
                          + vector_15[i]**2 + vector_16[i]**2 + vector_17[i]**2 
                          + vector_18[i]**2 + vector_19[i]**2 + vector_19[i]**2 + vector_20[i]**2
                          + vector_21[i]**2 + vector_22[i]**2 + vector_23[i]**2 
                          + vector_24[i]**2 + vector_25[i]**2 + vector_26[i]**2 + vector_27[i]**2
                          + vector_28[i]**2 + vector_29[i]**2 + vector_30[i]**2
                          + vector_31[i]**2 + vector_32[i]**2 + vector_33[i]**2 
                          + vector_34[i]**2 + vector_35[i]**2 + vector_36[i]**2 + vector_37[i]**2
                          + vector_38[i]**2 + vector_39[i]**2 + vector_40[i]**2 ) for i in range(num_columns) }
    important_features = sorted(zip(important_features.values(), important_features.keys()), reverse=True)
    print(type(important_features))
  
    Importantlist = []
    
    for pc in range(40):
        print("Features by importance:", pc , important_features[pc])
        Importantlist.append(important_features[pc])
    
                

get_important_features(T, pca.components_, df.columns.values)
